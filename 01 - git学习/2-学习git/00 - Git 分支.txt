Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成。
Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。
	理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。
	
初始提交后，现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个 树 对象 （记录着目录结构和 blob 对
象索引）以及一个 提交 对象（包含着指向前述树对象的指针和所有提交信息）。

	Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 
	Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 
	master 分支会在每次提交时自动向前移动。
		 之所以几乎每一个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动它。

一、常用本地分支命令
	
	由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 
	
	1 - 分支创建
		$ git branch  <new name>
			- HEAD 这个特殊指针， 让git知道当前所处的具体分支
	
	2 - 分支切换
		$ git checkout <branchname>
		$ git checkout -b <newbranchname>   创建新分支并同时切换过去
		
	3 - 分支合并
		$ git merge <branchname>
		--遇到冲突时的分支合并
			-如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。
			-- git 合并工具  mergetool
			- 高级合并
			
	4 - 删除分支
		$ git branch -d  <branchname>
		$ git branch -D  <branchname>    强制删除分支
		
    5 - 分支管理
		$ git branch      分支列表
			* 代表现在检出的那一个分支 （当前HEAD指针所指向的分支）
		$ git branch -v   查看每一个分支的最后一次提交
		$ git branch --merged      过滤列表中已经合并到当前分支的分支
		$ git branch --no-merged   过滤列表中尚未合并到当前分支的分支
		
二、分支开发工作流

	常见的利用分支进行开发的工作流程。
	
	1 - 长期分支
		- 在整个项目开发周期的不同阶段，您可以拥有多个开放的分支；
		- 您可以定期把某些主题分支合并入其他分支中；
		-- master 分支上保留完全稳定的代码   （已发布代码，或即将发布的代码）；
		-- develop 、 next 等平行分支 被用来做 后续开发 或者测试稳定性，  当达到稳定状态后就合并入master分支。
		--- 随着你的提交而不断右移的指针；
		--- 稳定分支的指针总在提交历史中落后一大截；
		--- 而前沿分支的指针往往比较靠前。
		---- 通常，把他们通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。
		---你可以用这种方法维护不同层次的稳定性。 
		---一些大型项目还有一个 proposed（建议） 或 pu: proposedupdates（建议更新）分支，
			-它可能因包含一些不成熟的内容而不能进入 next 或者 master 分支。 
			-这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 
				-尤其是当你在一个非常庞大或者复杂的项目中工作时，使用多个长期分支的方法通常很有帮助。

	2 - 主题分支
		- 主题分支对任何规模的项目都适用。 
		- 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。 
		- 然而，在 Git 中一天之内多次创建、使用、合并、删除分支都很常见。
		- 这项技术能使你快速并且完整地进行上下文切换（context-switch）
		- 你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，
		- 因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 
		- 你可以把做出的改动在主题分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。
		-- 我们将会在分布式 Git 中向你揭示更多有关分支工作流的细节， 你将决定项目要使用什么样的分支策略（branching scheme）。
		-- 当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。

三、远程分支

		- 远程引用是对远程仓库的引用（指针），包括分支、标签等等。 
		- $ git ls-remote <remote>     来显式地获得远程引用的完整列表 
		- $ git remote show <remote>   获得远程分支的更多信息
		-- 然而，一个更常见的做法是利用远程跟踪分支。
		-- 远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。
		-- 一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。
		-- 请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。
        -- 它们以 <remote>/<branch> 的形式命名。 
			- 例如，如果你想要看你最后一次与远程仓库 origin 通信时master 分支的状态，你可以查看 origin/master 分支。
		    - 你与同事合作解决一个问题并且他们推送了一个iss53 分支，
			- 你可能有自己的本地 iss53 分支，然而在服务器上的分支会以 origin/iss53 来表示。
		- 假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。 
		    - 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin，
			- 拉取它的所有数据， 创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。
			- Git 也会给你一个与 origin 的master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。
		- “origin” 并无特殊含义远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。
		- 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 git clone 时默认的远程仓库名字。
		- 如果你运行 git clone-o booyah，那么你默认的远程分支名字将会是 booyah/master。
	
	1 - 与给定的远程仓库同步数据  （拉取）
		$ git fetch <remote> 
		- 要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 
		- 这种情况下，不会有一个新的 serverfix 分支——只有一个不可以修改的 origin/serverfix 指针。

	
	2 - 公开分享一个分支 （推送）
		$ git push  <remote> <branch>
		-- 不愿意分享的内容不要推送
		
		- 如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。
		- 如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 
		- 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 git config --globalcredential.helper cache 来设置它。
		--  了解“凭证存储” ，掌握更多关于不同验证缓存的可用选项。
		
	3 - 跟踪分支
	
	
